#!/bin/bash

# logcmd
#
# Purpose: To log a command, and it's result code, to a log file.
#
# To use:
#   set logtarget
#   then preface each command in your bash file with . logcmd
#   does not yet have a quiet mode
#   does not yet have more than 2, hardwired subscribers, facilitated with tee
#   does not yet have real time log availability via the console, but coming...
#       probably using this or something similar: tail -f "${logtarget}" &
#
# Example: This is the unit test used, script called: testme
#  #!/bin/bash
#
#  # Unit test script for logcmd
#  export logtarget="${HOME}/testme.log"
#  . logcmd -n
#  . logcmd echo "\"Starting testme\""
#  . logcmd rsync_defaults_for_whole_drive_backup="\"--acls --archive --delete-before --executability --human-readable --one-file-system --verbose --verbose --xattrs\""
#
#  echo testing rsync_defaults_for_whole_drive_backup  2>&1 | tee -a ${logtarget}
#  echo rsync_defaults_for_whole_drive_backup=$rsync_defaults_for_whole_drive_backup   2>&1 | tee -a ${logtarget}
#
#  if [ -z "$rsync_defaults_for_whole_drive_backup" ]; then
#      echo "TESTME....: FAILED: rsync_defaults_for_whole_drive_backup is set INCORRECTLY to '$rsync_defaults_for_whole_drive_backup'""
#  else
#      echo "TESTME....: SUCCESS: rsync_defaults_for_whole_drive_backup is set CORRECTLY to '$rsync_defaults_for_whole_drive_backup'"
#  fi


# Set the default log file location if logtarget is not set
if [ -z "$logtarget" ]; then
    tmptarget="${HOME}/bin/AkienApps/logs/tmp"
    test ! -d "${tmptarget}" && mkdir "${tmptarget}"
    logtarget="${tmptarget}/${0##*/}.log"
    export logtarget
fi

# Now check to see if we have to create an empty file
if [ ":$1" == ":-n" ] ; then
    : > "${logtarget}" # Clear or create the log file
    shift
fi

# Akien's original code used: $@
command_line="$*"

if [ ! ":${command_line}" == ":" ] ; then
    # Define a function to get the timestamp in the required format
    timestamp() {
        date +"%Y-%m-%d.%H:%M:%S.%4N"
    }

    contarget=/tmp/contarget.log
    : > "${contarget}"

    # Log the command about to be executed
    echo "$(timestamp) \$ ${command_line}" | tee -a "${logtarget}"

    # Execute the command and redirect both stdout and stderr to the log file
    # We have to do it this way because using tee fails no matter what else we do.
    eval "$command_line" > "${contarget}" 2>&1

    # Capture the result code of the command
    result_code=$?

    # Check if the log file has content and display it line by line
    cat "${contarget}" | tee -a "${logtarget}"

    # Now remove it
    rm -f /tmp/contarget.log

    # Log the result code
    echo "$(timestamp) \$ result_code=$result_code" | tee -a "${logtarget}"
    echo "" | tee -a "${logtarget}"

    # Export the result code for further use if needed
    export result_code

    # Return the result code (optional)
    return "$result_code"
fi
